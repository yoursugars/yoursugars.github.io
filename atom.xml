<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A Palace For Sugar</title>
  
  <subtitle>软肋倒是越来越多。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursugars.github.io/"/>
  <updated>2018-09-20T10:02:58.184Z</updated>
  <id>https://yoursugars.github.io/</id>
  
  <author>
    <name>Sugar/Gray</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>密码学-欧几里得</title>
    <link href="https://yoursugars.github.io/2018/09/18/%E5%AF%86%E7%A0%81%E5%AD%A6-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97/"/>
    <id>https://yoursugars.github.io/2018/09/18/密码学-欧几里得/</id>
    <published>2018-09-18T12:53:56.000Z</published>
    <updated>2018-09-20T10:02:58.184Z</updated>
    
    <content type="html"><![CDATA[<h2 id="preparation"><a href="#preparation" class="headerlink" title="preparation"></a>preparation</h2><blockquote><p>加法消去律：如果(a+b)≡(a+c) mod m, 则b ≡ c mod m<br><br>乘法消去律：对于(a×b)≡(a×c) mod m，若gcd(a,m)=1，则b ≡ c mod m<br><br>(a和m互素)</p></blockquote><h3 id="逆元"><a href="#逆元" class="headerlink" title="逆元"></a>逆元</h3><h4 id="1-加法逆元-x-y-0"><a href="#1-加法逆元-x-y-0" class="headerlink" title="1.加法逆元 x-y=0"></a>1.加法逆元 x-y=0</h4><table><thead><tr><th style="text-align:center">Z<sub>4</sub></th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">3</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr></tbody></table><p>此时很清楚的看出来：<br><br>1). (0+4)<strong>mod</strong>4=0<br><br>2). (2+2)<strong>mod</strong>4=0<br><br>3). (1+3)<strong>mod</strong>4=0<br></p><p>此时0的加法逆元为4, 2的加法逆元为2, 1的加法逆元为3</p><h4 id="2-乘法逆元-x-y-1-1"><a href="#2-乘法逆元-x-y-1-1" class="headerlink" title="2.乘法逆元 x*y-1=1"></a>2.乘法逆元 x*y<sup>-1</sup>=1</h4><p>1).取非素数4<br>|Z<sub>4<sub>|0|1|2|3|<br>|:–:|:–:|:–:|:–:|:–:|<br>|0|0|0|0|0|<br>|1|0|1|2|3|<br>|2|0|2|0|2|<br>|3|0|3|2|1|</sub></sub></p><p>由于4不是素数，所以只有gcd(x,4)=1的有逆元：<br>此时0和2没有乘法逆元，而1的乘法逆元是1, 因为1×1=1. 3的乘法逆元是3, 因为3×3=1(行标和列标)</p><p>2).若取素数5：<br>|Z<sub>5<sub>|0|1|2|3|4|<br>|:–:|:–:|:–:|:–:|:–:|:–:|<br>|0|0|0|0|0|0|<br>|1|0|<strong>1</strong>|2|3|4|<br>|2|0|2|4|<strong>1</strong>|3|<br>|3|0|3|<strong>1</strong>|4|2|<br>|4|0|4|3|2|<strong>1</strong>|</sub></sub></p><p>此时1,2,3,4均有乘法逆元</p><p><strong>Q</strong>:乘法消去律,为什么一定要求要满足gcd(a,m)=1?<br><br><strong>A</strong>:模m的乘法运算返回的结果是0~(m-1)之间的数，如果乘数a和模数m有除1以外的共同因子,那么不会产生完整的余数集合.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;preparation&quot;&gt;&lt;a href=&quot;#preparation&quot; class=&quot;headerlink&quot; title=&quot;preparation&quot;&gt;&lt;/a&gt;preparation&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;加法消去律：如果(a+b)≡(a+c) m
      
    
    </summary>
    
    
      <category term="算法" scheme="https://yoursugars.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>英语语法-名词</title>
    <link href="https://yoursugars.github.io/2018/09/18/%E8%8B%B1%E8%AF%AD%E8%AF%AD%E6%B3%95-%E5%90%8D%E8%AF%8D/"/>
    <id>https://yoursugars.github.io/2018/09/18/英语语法-名词/</id>
    <published>2018-09-18T08:08:42.000Z</published>
    <updated>2018-09-20T09:57:05.647Z</updated>
    
    <content type="html"><![CDATA[<h2 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h2><blockquote><p>用来修饰名词短语的是定语<br>定语分为前置定语(放在名词前面)和后置定语(放在名词后面)<br>在语言学上，汉语被称作”中心词在后”的语言(head-last language);英语被称为”中心词在前”的语言(head-first language)</p></blockquote><h3 id="“左二右六”的定语规律"><a href="#“左二右六”的定语规律" class="headerlink" title="“左二右六”的定语规律"></a>“左二右六”的定语规律</h3><p>黄金公式： 限定词+形容词+<strong>中心名词(headword)</strong>+六类右置定语(介词短语/分词短语/不定时短语/形容词短语/定语从句/同位语从句)<br><a id="more"></a></p><h3 id="名词的定义和分类"><a href="#名词的定义和分类" class="headerlink" title="名词的定义和分类"></a>名词的定义和分类</h3><table><thead><tr><th style="text-align:center">英文中文</th><th style="text-align:center">月份</th></tr></thead><tbody><tr><td style="text-align:center">公历</td><td style="text-align:center">the solar calendar</td></tr><tr><td style="text-align:center">农历</td><td style="text-align:center">the lunar calendar</td></tr></tbody></table><p>(e.g.七夕:the seventh of the seventh lunar month)</p><h3 id="名词的数"><a href="#名词的数" class="headerlink" title="名词的数"></a>名词的数</h3><blockquote><p>怎么说呢？关于区分一个名词在哪用作复数，在哪用作单数：遵循如果是总称的，抽象的概念则为不可数；如果表示的是不同种类的，具体的，则为可数。</p></blockquote><p>1.常用作不可数名词的名词：<br><br>  1).对于一些无法分割的名词，看作一个整体(air)<br>  2).一些因其组成部分太小而不易数的名词(corn)<br>  3).表示总称的名词(furniture)<br>  4).抽象的名词一般是不可数的(advice)<br>  5).表示研究学科，一般作为不可数名词(biology)</p><p>2.<strong>但是怎么说呢？可数和不可数具有相对性</strong><br> 1).对于物质名词或总称的名词，若是表示不同的种类，或者因为<strong>特定</strong>的意思，或是液体表示“几杯”这样的数量，则转化为可数名词。(paper:纸/a paper:一份报纸)<br> 2).对于抽象的名词，如果具体化了，可以转化为可数名词。(beauty/ a beauty)<br> 3).当一个名词表示抽象的、总称的概念，作为不可数名词来用，当它表示具体的，特定的事物，则通常用作可数名词<br> e.g.I pronounce this couple to be <strong>husband</strong> and <strong>wife</strong>.</p><p>3.不可数名词的度量<br> 1).常用piece修饰抽象名词<br>    e.g. a piece of news<br> 2).用bottle, cup, drop, glass修饰液体<br> 3).其他的量词:<br>    e.g.a loaf of bread/a slice of meat</p><h3 id="错题："><a href="#错题：" class="headerlink" title="错题："></a>错题：</h3><p>I had some interesting <strong>experiences</strong> during the journey.(特指经历)<br><br>He gained <strong>experience</strong> in dealing with such people.(某种经验)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;名词&quot;&gt;&lt;a href=&quot;#名词&quot; class=&quot;headerlink&quot; title=&quot;名词&quot;&gt;&lt;/a&gt;名词&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;用来修饰名词短语的是定语&lt;br&gt;定语分为前置定语(放在名词前面)和后置定语(放在名词后面)&lt;br&gt;在语言学上，汉语被称作”中心词在后”的语言(head-last language);英语被称为”中心词在前”的语言(head-first language)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;“左二右六”的定语规律&quot;&gt;&lt;a href=&quot;#“左二右六”的定语规律&quot; class=&quot;headerlink&quot; title=&quot;“左二右六”的定语规律&quot;&gt;&lt;/a&gt;“左二右六”的定语规律&lt;/h3&gt;&lt;p&gt;黄金公式： 限定词+形容词+&lt;strong&gt;中心名词(headword)&lt;/strong&gt;+六类右置定语(介词短语/分词短语/不定时短语/形容词短语/定语从句/同位语从句)&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="英语" scheme="https://yoursugars.github.io/tags/%E8%8B%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>编译原理(2)</title>
    <link href="https://yoursugars.github.io/2018/09/13/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-2/"/>
    <id>https://yoursugars.github.io/2018/09/13/编译原理-2/</id>
    <published>2018-09-13T07:52:26.000Z</published>
    <updated>2018-09-13T07:52:26.253Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>操作系统(1)</title>
    <link href="https://yoursugars.github.io/2018/09/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-1/"/>
    <id>https://yoursugars.github.io/2018/09/06/操作系统-1/</id>
    <published>2018-09-06T03:01:06.000Z</published>
    <updated>2018-09-08T06:58:43.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、序论"><a href="#一、序论" class="headerlink" title="一、序论"></a>一、序论</h2><pre><code>&lt;!--more--&gt;</code></pre><h3 id="1-1-操作系统形成和发展"><a href="#1-1-操作系统形成和发展" class="headerlink" title="1.1.操作系统形成和发展"></a>1.1.操作系统形成和发展</h3><h4 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1).操作系统:"></a>1).操作系统:</h4><pre><code>1.是运行在计算机上的第一层系统软件2.是对硬件的首次扩充。3.做&quot;硬件相关、应用无关&quot;的工作 </code></pre><h4 id="2-操作系统的发展"><a href="#2-操作系统的发展" class="headerlink" title="2).操作系统的发展"></a>2).操作系统的发展</h4><pre><code>1.联机批处理解决了人机矛盾2.脱机批处理解决了CPU的高速度与I/O设备的低速度之间的矛盾3.批处理系统节省了卫星机，实现了主机和通道、主机和外设的并行操作，系统负责用户的I/O传输，检查用户I/O命令的合法性。(遇错解决)**通道**：CPU把数据传输的功能下放给通道,通道和CPU分时使用内存，实现CPU与外设的并行工作(CPU发送一条通道命令，然后由通道和外设交换数据，之后CPU做其他的事情，通道和外设交换为数据后再向CPU汇报，CPU再处理)| 时间段 | 操作系统 || :-: | :-: ||联机批处理|联机操作：若CPU直接控制I/O操作||脱机批处理|脱机操作：由卫星机负责I/O工作||执行系统(批处理系统)|借助通道和中断技术，由主机控制I/O传输，负责作业的自动调度，负责提供I/O控制功能|</code></pre><h4 id="3-多道程序设计技术"><a href="#3-多道程序设计技术" class="headerlink" title="3).多道程序设计技术"></a>3).多道程序设计技术</h4><blockquote><p>解决：一个程序只需要CPU进行大量的计算时，外部设备就无事可做；而当一个程序需要大量的I/O传输时，CPU就不得不处于等待状态。</p></blockquote><pre><code>多道特点：1.主存中同时存放几道互相独立的程序          2.宏观上并行，微观上串行</code></pre><h4 id="4-分时技术"><a href="#4-分时技术" class="headerlink" title="4).分时技术"></a>4).分时技术</h4><pre><code>1.脱机操作方式：程序运行过程中不能直接实施控制，需预料到所有的问题和情况2.联机操作方式：用户能直接控制程序的运行分时技术可以使一台计算机同时为多个终端用户服务成为可能：将处理机时间划分成很短的时间片，轮流地分配各个用户程序使用。</code></pre><h3 id="1-2-操作系统的定义和特性"><a href="#1-2-操作系统的定义和特性" class="headerlink" title="1.2.操作系统的定义和特性"></a>1.2.操作系统的定义和特性</h3><pre><code>组成操作系统的软件包括：系统软件、应用软件和工具软件操作系统的宗旨：**提高计算机系统的效率、方便用户的使用**1).分时通过进程号、用户号标识多用户一定是多任务(Unix/Linux)多任务不一定是多用户(windows pro)2).**并发**：多个任务在一个时间段上同时做**共享**：并发必共享**不确定**：可以处理随机发生的多个事件**虚拟**：比裸机工作更强</code></pre><h3 id="1-3-中断及其处理"><a href="#1-3-中断及其处理" class="headerlink" title="1.3.中断及其处理"></a>1.3.中断及其处理</h3><blockquote><p>中断是指某个事件(例如电源掉电、定点加法溢出或者I/O传输结束)发生时，系统中止先行程序的运行、中断返回(由中断返回指令实现)这几个步骤。而中断过程是由一个中断信号引发的。</p></blockquote><p>中断过程：硬件实现的中断进入-&gt;软件的中断处理过程-&gt;中断返回(由中断返回指令实现)<br>而中断过程是由一个中断信号引发的。</p><pre><code>3).</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、序论&quot;&gt;&lt;a href=&quot;#一、序论&quot; class=&quot;headerlink&quot; title=&quot;一、序论&quot;&gt;&lt;/a&gt;一、序论&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!--more--&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;1-1-操作系统形成和发展&quot;&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://yoursugars.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="课程" scheme="https://yoursugars.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>编译原理(1)</title>
    <link href="https://yoursugars.github.io/2018/09/05/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86-1/"/>
    <id>https://yoursugars.github.io/2018/09/05/编译原理-1/</id>
    <published>2018-09-05T11:11:07.000Z</published>
    <updated>2018-09-06T02:38:16.585Z</updated>
    
    <content type="html"><![CDATA[<p>其实老师之前说过的话或者提的意见其实都还是很有建设性的。</p><blockquote><p>1.为什么变量名不能使用数字？<br>假如变量名允许以数字开头的话，那么语法分析器在解析一个全部为数字的字串的时候，就无法判断它是一个数字常量还是一个变量名了<br>2.推荐了几本书<br>  1).程序员的自我修养<br>  2).深入理解Java虚拟机<br>  3).龙书虎书？<br>  4).《编译原理》清华大学 吕映之/张素琴<br>3.需要读gcc的源代码：<a href="http://gcc.gnu.org" target="_blank" rel="noopener">http://gcc.gnu.org</a><br>使用工具:source insight<br>找到了一个博客：<a href="https://blog.csdn.net/sonicling/article/details/6702031" target="_blank" rel="noopener">https://blog.csdn.net/sonicling/article/details/6702031</a></p></blockquote><p>以上算是前言吧 怎么说呢 还是想好好学学这门课 毕竟像“专业素养“这样的东西就很玄</p><a id="more"></a><h2 id="一、引论"><a href="#一、引论" class="headerlink" title="一、引论"></a>一、引论</h2><h3 id="1-1-课堂笔记"><a href="#1-1-课堂笔记" class="headerlink" title="1.1.课堂笔记"></a>1.1.课堂笔记</h3><p> 1).硬件：并行/ 软件：抽象<br> 2).什么是高级语言？与机器无关<br> 3).编译和解释：<br>    <strong>编译</strong>：生成目标程序 优点：效率高,生成的目标程序直接运行时速度快<br>    <strong>解释</strong>：边解释边运行 优点：方便诊断错误<br> 4).针对C语言：编译运行<br>    针对Java语言：首先编译为字节码(bytecode)的形式—&gt;利用Java虚拟机解释执行<br> 5).语言处理系统<br> <img src="/2018/09/05/编译原理-1/a1.png" alt="一个语言处理系统"></p><table><thead><tr><th style="text-align:center">工具(e.g. in C)</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">预处理器</td><td style="text-align:center">替换宏(#define)、替换头文件(#include)、预编译(#if def):将头文件插入到本文件中，增加行号等</td></tr><tr><td style="text-align:center">编译器</td><td style="text-align:center">产生二进制代码or汇编语言</td></tr><tr><td style="text-align:center">汇编器</td><td style="text-align:center">生成可重定位的机器代码</td></tr><tr><td style="text-align:center">链接器</td><td style="text-align:center">在运行库函数时定位</td></tr><tr><td style="text-align:center">加载器</td><td style="text-align:center">加载到内存中</td></tr></tbody></table><p> 6).register变量：设置变量在寄存器中，存取速度快<br> 7).inline(内联函数):在本地中插入该函数，<strong>就地展开</strong>,速度快。为什么还要调用函数？代码简洁 以时间换空间。</p><h3 id="1-2-课后扩展"><a href="#1-2-课后扩展" class="headerlink" title="1.2.课后扩展"></a>1.2.课后扩展</h3><p>  1).静态策略：在编译时就可以确定的问题<br>     动态策略：只允许在运行程序时做出的策略</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实老师之前说过的话或者提的意见其实都还是很有建设性的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1.为什么变量名不能使用数字？&lt;br&gt;假如变量名允许以数字开头的话，那么语法分析器在解析一个全部为数字的字串的时候，就无法判断它是一个数字常量还是一个变量名了&lt;br&gt;2.推荐了几本书&lt;br&gt;  1).程序员的自我修养&lt;br&gt;  2).深入理解Java虚拟机&lt;br&gt;  3).龙书虎书？&lt;br&gt;  4).《编译原理》清华大学 吕映之/张素琴&lt;br&gt;3.需要读gcc的源代码：&lt;a href=&quot;http://gcc.gnu.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://gcc.gnu.org&lt;/a&gt;&lt;br&gt;使用工具:source insight&lt;br&gt;找到了一个博客：&lt;a href=&quot;https://blog.csdn.net/sonicling/article/details/6702031&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/sonicling/article/details/6702031&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以上算是前言吧 怎么说呢 还是想好好学学这门课 毕竟像“专业素养“这样的东西就很玄&lt;/p&gt;
    
    </summary>
    
    
      <category term="课程" scheme="https://yoursugars.github.io/tags/%E8%AF%BE%E7%A8%8B/"/>
    
      <category term="编译原理" scheme="https://yoursugars.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>太阳全盘图像的去云处理</title>
    <link href="https://yoursugars.github.io/2018/08/22/%E5%A4%AA%E9%98%B3%E5%85%A8%E7%9B%98%E5%9B%BE%E5%83%8F%E7%9A%84%E5%8E%BB%E4%BA%91%E5%A4%84%E7%90%86/"/>
    <id>https://yoursugars.github.io/2018/08/22/太阳全盘图像的去云处理/</id>
    <published>2018-08-22T13:33:50.000Z</published>
    <updated>2018-09-05T11:13:05.481Z</updated>
    
    <content type="html"><![CDATA[<p>应该反思一下为什么写作的时候没有什么想写的 就在反思中总结进步嘛<br>一张图送给自己：<br><img src="/2018/08/22/太阳全盘图像的去云处理/a.jpg" alt="avatar"></p><a id="more"></a><h2 id="一、评分标准"><a href="#一、评分标准" class="headerlink" title="一、评分标准"></a>一、评分标准</h2><p>没有想到的：</p><h3 id="1-图像的异常处理"><a href="#1-图像的异常处理" class="headerlink" title="1.图像的异常处理"></a>1.图像的异常处理</h3><p>我记得去年第一轮淘汰赛 就好像是对成绩进行分析 那个时候都记得去除异常值了 这次光想着怎么预处理图像了 完全忘记了还要去除异常值。</p><h3 id="2-去云效果评价模型"><a href="#2-去云效果评价模型" class="headerlink" title="2.去云效果评价模型"></a>2.去云效果评价模型</h3><p>如果使用了那么多模型 应该通过评价来表明处理效果 其实就是如果要你做什么处理 就可以通过评价模型 成为加分项</p><h3 id="3-云量分级"><a href="#3-云量分级" class="headerlink" title="3.云量分级"></a>3.云量分级</h3><p>云量分级之后需要仔细说明169张图的分级&amp;给出多个评价指标 这个因为我写结果分析写的太迟了 </p><h2 id="二、自我反思"><a href="#二、自我反思" class="headerlink" title="二、自我反思"></a>二、自我反思</h2><blockquote><p>1.数据处理：异常处理&amp;这次用的registax6和PS<br>  2.格式不要想着最后调因为我们最后可能及其没有时间<br>  3.摘要提前改 以及 结果分析提前写好<br>  4.最好不要捣鼓一些非常麻烦的软件 因为极有可能到最后还调不出来<br>  5.问题分析提前写多一点 到时候可以删<br>  6.主动看模型 找代码</p></blockquote><h2 id="三、对registax6的处理准备"><a href="#三、对registax6的处理准备" class="headerlink" title="三、对registax6的处理准备"></a>三、对registax6的处理准备</h2><p>  1.软件下载：(3M对处理图像的软件已经够小了)<br>  <a href="http://www.astronomie.be/registax/download.html" target="_blank" rel="noopener">http://www.astronomie.be/registax/download.html</a><br>  2.参考教程<br>  <a href="https://jingyan.baidu.com/article/154b4631b2419328ca8f4104.html?qq-pf-to=pcqq.c2c" target="_blank" rel="noopener">https://jingyan.baidu.com/article/154b4631b2419328ca8f4104.html?qq-pf-to=pcqq.c2c</a><br>  <a href="http://familystar.org.tw/component/option,com_smf/Itemid,45/topic,14052.0" target="_blank" rel="noopener">http://familystar.org.tw/component/option,com_smf/Itemid,45/topic,14052.0</a><br>  <a href="http://blog.sina.com.cn/s/blog_4a5215000101q4rs.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4a5215000101q4rs.html</a><br>  3.主要是因为是fts文件 registax6是可以处理fts的 但是它处理的一般是一整个视频 通过叠加锐化 我一开始总是用一张fts图像来处理 就处理不了 后来选择一系列图像之后才稍微好一线</p><h2 id="四、envi5-3-去云补丁"><a href="#四、envi5-3-去云补丁" class="headerlink" title="四、envi5.3+去云补丁"></a>四、envi5.3+去云补丁</h2><p>   1.下载地址：</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应该反思一下为什么写作的时候没有什么想写的 就在反思中总结进步嘛&lt;br&gt;一张图送给自己：&lt;br&gt;&lt;img src=&quot;/2018/08/22/太阳全盘图像的去云处理/a.jpg&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="https://yoursugars.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
  <entry>
    <title>拓扑排序</title>
    <link href="https://yoursugars.github.io/2018/08/07/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://yoursugars.github.io/2018/08/07/拓扑排序/</id>
    <published>2018-08-07T11:47:26.000Z</published>
    <updated>2018-08-07T12:16:44.548Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实我特不喜欢 写一个题发一个博客 因为我觉得写博客的目的是为了精简和记忆与回忆 但是我觉得我这个拓扑排序的代码写的太好看了 借鉴了别人的思路 但是代码简洁优美 唉 是我为数不多写题的时候思路清晰 突然醍醐灌顶 就写这个博客之后来看 ヾ(✿ﾟ▽ﾟ)ノ</p></blockquote><p><br><br>拓扑排序 我自从第一次学习之后就再没有忘记了<br>一句话解释：以次输出入度为0的点</p><a id="more"></a><p><strong>题目内容</strong><br>有N个比赛队（1&lt;=N&lt;=500），编号依次为1,2,3,…,N进行比赛，比赛结束后，裁判委员会要将所有参赛队伍从前往后依次排名，但现在裁判委员会不能直接获得每个队的比赛成绩，只知道每场比赛的结果，即P1赢P2，用P1，P2表示，排名时P1在P2之前。现在请你编程序确定排名。</p><p><strong>输入描述</strong><br>输入有若干组，每组中的第一行为二个数N（1&lt;=N&lt;=500），M；其中N表示队伍的个数，M表示接着有M行的输入数据。接下来的M行数据中，每行也有两个整数P1，P2表示即P1队赢了P2队。</p><p><strong>输出描述</strong><br>给出一个符合要求的排名。输出时队伍号之间有空格，最后一名后面没有空格。<br>其他说明：符合条件的排名可能不是唯一的，此时要求输出时编号小的队伍在前；输入数据保证是正确的，即输入数据确保一定能有一个符合要求的排名。</p><p><strong>输入样例</strong></p><blockquote><p>4 3<br>1 2<br>2 3<br>4 3</p></blockquote><p><strong>输出样例</strong></p><blockquote><p>1 2 4 3</p></blockquote><p>你看这个样例 然后你再看数据结构是啥样的：邻接表<br>还是画个图 我感觉我过两天就忘记了<br><img src="/2018/08/07/拓扑排序/a1.png" alt="avatar"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> nmax 505</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[nmax]; <span class="comment">//此乃邻接表 </span></span><br><span class="line"><span class="keyword">int</span> indegree[nmax]; <span class="comment">//用来存每个点的入度 </span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; ans;  </span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q; <span class="comment">//从小到大优先队列 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="keyword">if</span>(indegree[i] == <span class="number">0</span>)</span><br><span class="line">q.push(i);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.top();q.pop();</span><br><span class="line">ans.push(x);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v[x].size(); i++) </span><br><span class="line">&#123;</span><br><span class="line">indegree[v[x][i]]--;</span><br><span class="line"><span class="keyword">if</span>(indegree[v[x][i]] == <span class="number">0</span>)</span><br><span class="line">q.push(v[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">indegree[y]++;</span><br><span class="line">v[x].push_back(y);</span><br><span class="line">&#125;</span><br><span class="line">topsort();</span><br><span class="line"><span class="keyword">int</span> ansNum = ans.size();<span class="comment">//我也真是惊了 这里不能i&lt;ans.size() 因为它会变化... </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ansNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ans.front() &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">ans.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;其实我特不喜欢 写一个题发一个博客 因为我觉得写博客的目的是为了精简和记忆与回忆 但是我觉得我这个拓扑排序的代码写的太好看了 借鉴了别人的思路 但是代码简洁优美 唉 是我为数不多写题的时候思路清晰 突然醍醐灌顶 就写这个博客之后来看 ヾ(✿ﾟ▽ﾟ)ノ&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;拓扑排序 我自从第一次学习之后就再没有忘记了&lt;br&gt;一句话解释：以次输出入度为0的点&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://yoursugars.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="https://yoursugars.github.io/2018/08/07/css/"/>
    <id>https://yoursugars.github.io/2018/08/07/css/</id>
    <published>2018-08-07T07:01:45.000Z</published>
    <updated>2018-08-15T12:13:19.571Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前端实训"><a href="#前端实训" class="headerlink" title="前端实训"></a>前端实训</h3><p>说好不学前端的呢</p><p><img src="/2018/08/07/css/a1.png" alt="avatar"></p><h2 id="hBuilder快捷键"><a href="#hBuilder快捷键" class="headerlink" title="hBuilder快捷键"></a>hBuilder快捷键</h2><pre><code>1. shift + ↑↓←→  选中2. shift + Table 反退格3. control+ /    一键注释</code></pre><a id="more"></a><h2 id="css"><a href="#css" class="headerlink" title="css"></a>css</h2> <link rel="stylesheet" type="text/css" href="css/netEase_style.css"><blockquote><p>优先级：<br>    行内样式    &gt; 内部样式     &gt; 外部样式<br>    ID选择器(#) &gt; 类选择器(.)  &gt; 标签选择器    </p></blockquote><table><thead><tr><th style="text-align:center">选择器</th><th style="text-align:center">meaning</th></tr></thead><tbody><tr><td style="text-align:center">E&gt;F</td><td style="text-align:center">子代选择器</td></tr><tr><td style="text-align:center">E F</td><td style="text-align:center">后代选择器</td></tr><tr><td style="text-align:center">E+F</td><td style="text-align:center">相邻兄弟选择器(紧接在另一元素后的元素 且二者有相同父元素)</td></tr><tr><td style="text-align:center">E~F</td><td style="text-align:center">通用兄弟选择器(考虑后面的兄弟 不考虑自己)</td></tr></tbody></table><h3 id="一些常用的css"><a href="#一些常用的css" class="headerlink" title="一些常用的css"></a>一些常用的css</h3><p> 1.line-height:文字也居中<br> 2.text-indent:文字缩进 em(字符单位)<br> 3.list-style: 表格样式none<br> 4.text-style: 文字样式下划线etc<br> 5.background:linear-gradient(to bottom,green,orange,red);<br> 6.font-size:italic<br> 7.font-weight:bold<br> 8.font-family: “Times New Roman”, “楷体”;<br> 9.vertical-align:<br> 10.text-shadow: color  x-offset  y-offset  blur-radius;<br> 11.transform: translate();</p><p> a:hover<br> a:active</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前端实训&quot;&gt;&lt;a href=&quot;#前端实训&quot; class=&quot;headerlink&quot; title=&quot;前端实训&quot;&gt;&lt;/a&gt;前端实训&lt;/h3&gt;&lt;p&gt;说好不学前端的呢&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/08/07/css/a1.png&quot; alt=&quot;avatar&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;hBuilder快捷键&quot;&gt;&lt;a href=&quot;#hBuilder快捷键&quot; class=&quot;headerlink&quot; title=&quot;hBuilder快捷键&quot;&gt;&lt;/a&gt;hBuilder快捷键&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;1. shift + ↑↓←→  选中
2. shift + Table 反退格
3. control+ /    一键注释
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://yoursugars.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>dijkstra邻接矩阵与邻接表</title>
    <link href="https://yoursugars.github.io/2018/08/05/dijkstra%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"/>
    <id>https://yoursugars.github.io/2018/08/05/dijkstra邻接矩阵与邻接表/</id>
    <published>2018-08-05T09:41:12.000Z</published>
    <updated>2018-08-05T10:03:36.238Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述</strong><br>所以草儿决定在要在最短的时间去一个自己想去的地方！<br>因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车。</p><p><strong>输入描述</strong><br>输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；<br>接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&lt;(a,b)&lt;=1000;a,b 之间可能有多条路)<br>接着的第T+1行有S个数，表示和草儿家相连的城市；<br>接着的第T+2行有D个数，表示草儿想去地方。</p><p><strong>输出描述</strong><br>输出草儿能去某个喜欢的城市的最短时间。</p><a id="more"></a><p><strong>输入样例</strong><br>6 2 3<br>1 3 5<br>1 4 7<br>2 8 12<br>3 8 4<br>4 9 12<br>9 10 2<br>1 2<br>8 9 10</p><p><strong>输出样例</strong><br>9</p><p><strong>震惊</strong>：<em>这道题其实一次Dijkstra就可以了，我们将草儿的家看做0，从草儿家到相邻镇的花费看做0，那么我们就只需要求草儿家到各个目的地的最短路即可，一次Dijkstra便可解决</em><br>设置一个点 使其到起点的距离为0，再逐步更新其他的点？</p><h3 id="dijstra邻接矩阵"><a href="#dijstra邻接矩阵" class="headerlink" title="dijstra邻接矩阵"></a>dijstra邻接矩阵</h3><p>很显然邻接矩阵简单一些 但是数据大的话 就十分的不管用了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Ni = <span class="number">1005</span>;</span><br><span class="line"><span class="keyword">int</span> graph[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="keyword">int</span> dis[Ni], n, Max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">1005</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, w;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> m, <span class="keyword">int</span> n)&#123;a=m; w=n;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; x) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w==x.w) <span class="keyword">return</span> a&lt;x.a; <span class="comment">//返回另一个顶点小的那个 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> w &gt; x.w; <span class="comment">//返回权值小的那个 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="comment">//源点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= Max; i++)</span><br><span class="line">    visited[i] = <span class="literal">false</span>;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.push(node(s, dis[s]));  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node x = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span>(visited[x.a])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        visited[x.a] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">1</span>; v &lt;= Max; v++) <span class="comment">//找所有与他相邻的顶点，进行松弛操作，更新估算距离，压入队列。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(v != x.a &amp;&amp; !visited[v] &amp;&amp; dis[v] &gt; dis[x.a]+graph[x.a][v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v] = dis[x.a]+graph[x.a][v];</span><br><span class="line">                q.push(node(v, dis[v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> T, S, D, a, b, w;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;T, &amp;S, &amp;D) != EOF)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(graph, INF, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">        <span class="keyword">while</span>(T--)<span class="comment">//T条边 </span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;w);</span><br><span class="line">            graph[a][b] = min(graph[a][b], w);</span><br><span class="line">            graph[b][a] = min(graph[b][a], w);</span><br><span class="line">Max = max(Max, max(a, b));<span class="comment">//没给最大的点 不然就不用求了 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S; i++)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">        Dijkstra(n);</span><br><span class="line"><span class="comment">//        for(int i = 1; i &lt;= 10; i++)</span></span><br><span class="line"><span class="comment">//        printf("%d ", dis[i]);</span></span><br><span class="line"><span class="comment">//       printf("\n");</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">int</span> min = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; D; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">if</span>(min &gt; dis[n])</span><br><span class="line">min = dis[n];</span><br><span class="line">&#125; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, min); </span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dijstra邻接表"><a href="#dijstra邻接表" class="headerlink" title="dijstra邻接表"></a>dijstra邻接表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF  0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> Ni = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v,w;</span><br><span class="line">    node()&#123;&#125;</span><br><span class="line">    node(<span class="keyword">int</span> a,<span class="keyword">int</span> b)&#123;v=a; w=b;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node &amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(w==a.w) <span class="keyword">return</span> v&lt;a.v; <span class="comment">//返回另一个顶点小的那个 </span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> w &gt; a.w; <span class="comment">//返回权值小的那个 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; eg[Ni]; <span class="comment">//每个点都有一个向量存其临边 </span></span><br><span class="line"><span class="keyword">int</span> dis[Ni],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++) dis[i]=INF;</span><br><span class="line">    dis[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//用优先队列优化</span></span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    q.push(node(s,dis[s]));  </span><br><span class="line">    <span class="keyword">while</span>(!q.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        node x=q.top();q.pop();</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;eg[x.v].size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            node y=eg[x.v][i];</span><br><span class="line">            <span class="keyword">if</span>(dis[y.v]&gt;x.w+y.w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[y.v]=x.w+y.w;</span><br><span class="line">                q.push(node(y.v,dis[y.v]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a,b,d,m;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m),n+m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++) eg[i].clear();</span><br><span class="line">        <span class="keyword">while</span>(m--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;a,&amp;b,&amp;d);</span><br><span class="line">            eg[a].push_back(node(b,d));</span><br><span class="line">            eg[b].push_back(node(a,d));</span><br><span class="line">            <span class="comment">//题目上需要更新 node的距离 有点麻烦了 要搜索所有的临边 所以不在这题采用邻接表了 </span></span><br><span class="line">        &#125;</span><br><span class="line">        Dijkstra(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,dis[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;br&gt;所以草儿决定在要在最短的时间去一个自己想去的地方！&lt;br&gt;因为草儿的家在一个小镇上，没有火车经过，所以她只能去邻近的城市坐火车。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入描述&lt;/strong&gt;&lt;br&gt;输入数据有多组，每组的第一行是三个整数T，S和D，表示有T条路，和草儿家相邻的城市的有S个，草儿想去的地方有D个；&lt;br&gt;接着有T行，每行有三个整数a，b，time,表示a,b城市之间的车程是time小时；(1=&amp;lt;(a,b)&amp;lt;=1000;a,b 之间可能有多条路)&lt;br&gt;接着的第T+1行有S个数，表示和草儿家相连的城市；&lt;br&gt;接着的第T+2行有D个数，表示草儿想去地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出描述&lt;/strong&gt;&lt;br&gt;输出草儿能去某个喜欢的城市的最短时间。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://yoursugars.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法模板" scheme="https://yoursugars.github.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>SPFA与差分约束</title>
    <link href="https://yoursugars.github.io/2018/08/05/SPFA%E4%B8%8E%E5%B7%AE%E5%88%86%E7%BA%A6%E6%9D%9F/"/>
    <id>https://yoursugars.github.io/2018/08/05/SPFA与差分约束/</id>
    <published>2018-08-05T08:15:50.000Z</published>
    <updated>2018-08-05T09:33:58.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="思考：差分约束"><a href="#思考：差分约束" class="headerlink" title="思考：差分约束"></a>思考：差分约束</h3><table><thead><tr><th style="text-align:center">$max(x_1-x_2)$</th><th style="text-align:center">$min(x_1-x_2)$</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/2018/08/05/SPFA与差分约束/a1.png" alt="avatar"></td><td style="text-align:center"><img src="/2018/08/05/SPFA与差分约束/a2.png" alt="avatar"></td></tr><tr><td style="text-align:center">求最短路</td><td style="text-align:center">求最长路</td></tr><tr><td style="text-align:center">即在满足所有不等式的情况下 松弛所有的边 由于$\leq$ 求max的边界情况</td><td style="text-align:center">求最长路 松边 由于$\geq$ 求min的边界情况</td></tr></tbody></table><p>$min(x_1-x_2) = -max(x_2-x_1)$<br>其实就是把不等式乘以-1 求<br>在代码里直接 松弛的时候 dis[es[e].v] &lt; dis[x]+es[e].w 变符号大小就行</p><a id="more"></a><h3 id="题目-POJ-1201-Interval"><a href="#题目-POJ-1201-Interval" class="headerlink" title="题目 POJ 1201 Interval"></a>题目 POJ 1201 Interval</h3><p><a href="http://poj.org/problem?id=1201" target="_blank" rel="noopener">题目链接</a><br><a href="https://www.cnblogs.com/gj-Acit/p/3261721.html" target="_blank" rel="noopener">参考</a></p><p><strong>题目内容</strong><br>三元组（ai，bi，ci）表示在整数区间[ai,bi]上至少有ci个整数属于集合Z。（整数集合Z的元素可以不连续）<br>问Z最少包含多少个点。</p><p><strong>输入描述</strong><br>第一行一个整数n，表示区间个数.(1 &lt;= n &lt;= 50000)<br>以下n行，每行是三个整数ai，bi，ci，由空格隔开</p><p><strong>输出描述</strong><br>Z的元素个数</p><p><strong>输入样例</strong><br>5<br>3 7 3<br>8 10 3<br>6 8 1<br>1 3 1<br>10 11 1</p><p><strong>输出样例</strong><br>6</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_E 50005</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> next, v, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dis[MAX_E], head[MAX_E], vis[MAX_E], num[MAX_E];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> n, minn = INF, maxx = -INF;</span><br><span class="line">edge es[MAX_E];</span><br><span class="line"> </span><br><span class="line"><span class="comment">//数组实现邻接表，head提前初始化为-1 head存最后一条起点为u的边的编号 从后往前 </span></span><br><span class="line"><span class="comment">// cnt表示为边的编号 一个点的第一条边next=-1，遇到相同起点的边 </span></span><br><span class="line"><span class="comment">//.next = head[u]也就是(head存最后一条起点为u的边的编号) 然后head[u]存最后一条边(cnt自加前) </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">es[cnt].v = v;</span><br><span class="line">es[cnt].w = w;</span><br><span class="line">es[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPFA</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = minn; i &lt;= maxx; i++)</span><br><span class="line">dis[i] = -INF;</span><br><span class="line">dis[s] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(s);</span><br><span class="line"><span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line"><span class="keyword">int</span> x = q.front(); q.pop();</span><br><span class="line">vis[x] = <span class="number">0</span>;<span class="comment">//判断此点是否在队列中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> e = head[x]; e != <span class="number">-1</span>; e=es[e].next)</span><br><span class="line"><span class="keyword">if</span>(dis[es[e].v] &lt; dis[x]+es[e].w)<span class="comment">//只有松弛的 才可能继续松弛 </span></span><br><span class="line">&#123;</span><br><span class="line">dis[es[e].v] = dis[x]+es[e].w;</span><br><span class="line"><span class="keyword">if</span>(!vis[es[e].v])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt == ++num[es[e].v]) <span class="comment">//最多经过其他所有点松弛，超过证明有环 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"存在负环"</span>;</span><br><span class="line">q.push(es[e].v);</span><br><span class="line">vis[es[e].v] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="built_in">memset</span>(dis, INF, <span class="keyword">sizeof</span>(dis));</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line"><span class="built_in">memset</span>(num, <span class="number">0</span>, <span class="keyword">sizeof</span>(num));</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">add(u, v+<span class="number">1</span>, w);</span><br><span class="line">minn = min(minn, u);</span><br><span class="line">maxx = max(maxx, v+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = minn; i &lt; maxx; i++)</span><br><span class="line">&#123;</span><br><span class="line">add(i, i+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">add(i+<span class="number">1</span>, i, <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sbi - Sai &gt;= ci</span></span><br><span class="line"><span class="comment">Si - Si-1 &gt;= 0</span></span><br><span class="line"><span class="comment">Si-1 - Si &gt;= -1</span></span><br><span class="line"><span class="comment">可以看做在一条线上 区间上的数 数量不同 0至8的数&gt;=0至6的数 但 1&gt;=(0至8)-(0至7)&gt;=0 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">SPFA(minn);<span class="comment">//传源点 </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dis[maxx] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;思考：差分约束&quot;&gt;&lt;a href=&quot;#思考：差分约束&quot; class=&quot;headerlink&quot; title=&quot;思考：差分约束&quot;&gt;&lt;/a&gt;思考：差分约束&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$max(x_1-x_2)$&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;$min(x_1-x_2)$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/2018/08/05/SPFA与差分约束/a1.png&quot; alt=&quot;avatar&quot;&gt;&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;&lt;img src=&quot;/2018/08/05/SPFA与差分约束/a2.png&quot; alt=&quot;avatar&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;求最短路&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;求最长路&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;即在满足所有不等式的情况下 松弛所有的边 由于$\leq$ 求max的边界情况&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;求最长路 松边 由于$\geq$ 求min的边界情况&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$min(x_1-x_2) = -max(x_2-x_1)$&lt;br&gt;其实就是把不等式乘以-1 求&lt;br&gt;在代码里直接 松弛的时候 dis[es[e].v] &amp;lt; dis[x]+es[e].w 变符号大小就行&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://yoursugars.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法模板" scheme="https://yoursugars.github.io/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib</title>
    <link href="https://yoursugars.github.io/2018/08/02/matplotlib/"/>
    <id>https://yoursugars.github.io/2018/08/02/matplotlib/</id>
    <published>2018-08-02T08:37:34.000Z</published>
    <updated>2018-08-02T09:22:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>画图吧</p><a id="more"></a><h2 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#条形图</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line"><span class="comment">#模拟ggplot2风格</span></span><br><span class="line">customers=[<span class="string">'Sugar'</span>, <span class="string">'Xuyaqi'</span>, <span class="string">'YYX'</span>, <span class="string">'XYQ'</span>, <span class="string">'Gray'</span>, <span class="string">'Dean'</span>]</span><br><span class="line">customers_index = range(len(customers))</span><br><span class="line"><span class="comment">#创建客户索引列表</span></span><br><span class="line">customers_sale=[<span class="number">127</span>, <span class="number">190</span>, <span class="number">245</span>, <span class="number">23</span>, <span class="number">85</span>, <span class="number">56</span>]</span><br><span class="line">figure = plt.figure()</span><br><span class="line">ax1 = figure.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax1.bar(customers_index, customers_sale, align=<span class="string">'center'</span>, color = <span class="string">'darkblue'</span>)</span><br><span class="line">ax1.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br><span class="line">ax1.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br><span class="line">plt.xticks(customers_index, customers, rotation = <span class="number">0</span>, fontsize = <span class="string">'small'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Customer Name'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Sale Amount'</span>)</span><br><span class="line">plt.title(<span class="string">'What you want?'</span>)</span><br><span class="line">plt.savefig(<span class="string">'bar_plot.png'</span>, dpi = <span class="number">400</span>, bbox_inches = <span class="string">'tight'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h2 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#直方图</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.style.use(<span class="string">'ggplot'</span>)</span><br><span class="line">mu1, mu2, sigma = <span class="number">100</span>, <span class="number">130</span>, <span class="number">15</span></span><br><span class="line">x1 = mu1+sigma*np.random.random(<span class="number">10000</span>)</span><br><span class="line">x2 = mu2+sigma*np.random.random(<span class="number">10000</span>)</span><br><span class="line"><span class="comment">#创建两个正态分布变量x1和x2</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">n, bins, patches = ax1.hist(x1, bins = <span class="number">50</span>, density = <span class="keyword">True</span>, color=<span class="string">'darkgreen'</span>)</span><br><span class="line">b, bins, patches = ax1.hist(x2, bins = <span class="number">50</span>, density = <span class="keyword">False</span>, color = <span class="string">'orange'</span>, alpha = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#bins表示每个变量的值被分为50份 normed=False表示显示频率分布而不是概率密度 alpha=0.5表示透明</span></span><br><span class="line"></span><br><span class="line">ax1.xaxis.set_ticks_position(<span class="string">'bottom'</span>)</span><br><span class="line">ax1.yaxis.set_ticks_position(<span class="string">'left'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'Bins'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Number of Value in Bin'</span>)</span><br><span class="line">fig.suptitle(<span class="string">'Histograms'</span>, fontsize=<span class="number">14</span>, fontweight=<span class="string">'bold'</span>)</span><br><span class="line">ax1.set_title(<span class="string">'Two Frequency Distributions'</span>)</span><br><span class="line">plt.savefig(<span class="string">'histogram.png'</span>, dpi=<span class="number">400</span>, bbox_inches = <span class="string">'tight'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;画图吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://yoursugars.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>单调递增子序列</title>
    <link href="https://yoursugars.github.io/2018/06/30/%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>https://yoursugars.github.io/2018/06/30/单调递增子序列/</id>
    <published>2018-06-30T05:49:51.000Z</published>
    <updated>2018-06-30T08:00:14.573Z</updated>
    
    <content type="html"><![CDATA[<h2 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h2><blockquote><p>为啥不能使用暴力解决这个问题：设A串长为n. A串子序列个数$ 2^n $,判断其是否递增,时间复杂度变为:$ O(n*2^n) $. </p><font face="Console">And of course we cannot accept that.<br><br>所以出现了基本上以下三种方式：两个$O(n^2)$可求出序列本身，一个$ O(nlogn) $求出序列最大长度</font></blockquote><h3 id="前言：最长公共子序列"><a href="#前言：最长公共子序列" class="headerlink" title="前言：最长公共子序列"></a>前言：最长公共子序列</h3><p>子序列可以不连续，但是有先后的次序关系.</p><blockquote><p>为啥不能使用暴力解决这个问题：设A串长为n, B串长为m。A串子序列个数$2^n$, B串子序列个数$2^m$, 针对每一种情况进行匹配，时间复杂度变为： $O(2^n*2^m)$. </p></blockquote><a id="more"></a><p>所以利用动态规划：<br>A = {a, b, c, 1, 2, 3, a, b, c}<br>B = {1, 2, 3, a, d, c}</p><p><strong>定义状态:</strong><br>dp[i][j]: A串第i个位置，B串第j个位置前的两个序列的最大公共子序列.</p><p><strong>状态转移方程:</strong><br>①A[i] == B[j] -&gt; dp[i][j] = dp[i-1][j-1] + 1<br><em>explanation:</em><br>字符串匹配时:i, j位置之前的最长公共子序列就是i-1,  j-1位置之前的长度+1</p><p>②A[i] != B[j] -&gt; dp[i][j] = max(dp[i-1][j], dp[i][j-1])<br><em>explanation:</em><br>字符串不匹配时，最长公共子序列的长度是不会变的，但是我们有两种选择，就是在[i，j-1]位置以前的和[i，j-1]位置以前的两种情况之中，选取最大的最长公共子序列作为当前的最长公共子序列即可.</p><p><img src="/2018/06/30/单调递增子序列/img/a1.png" alt="avatar"></p><p>NYOJ.最长公共子序列<br><a href="http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=36" target="_blank" rel="noopener">http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=36</a></p><h3 id="一、-o-n-2-方法"><a href="#一、-o-n-2-方法" class="headerlink" title="一、$o(n^2)$方法"></a>一、$o(n^2)$方法</h3><h4 id="1-转化成最长公共子序列求解"><a href="#1-转化成最长公共子序列求解" class="headerlink" title="1.转化成最长公共子序列求解"></a>1.转化成最长公共子序列求解</h4><p>原序列为A，把A按升序排序得到序列B，求出A，B序列的最长公共子序列，即为A的最长单调递增子序列。</p><h4 id="2-带有一定动态规划思想的-O-n-2"><a href="#2-带有一定动态规划思想的-O-n-2" class="headerlink" title="2.带有一定动态规划思想的$O(n^2)$"></a>2.带有一定动态规划思想的$O(n^2)$</h4><p><strong>定义状态：</strong><br>d[i]为以第i个元素结尾的最长递增子序列的长度</p><p><strong>状态转移方程：</strong><br>A[j] &lt; A[i]: d[j] = max{d[i], d[j]+1}<br>对于每一个i，令j从i-1到0遍历，当a[j] &lt; a[i]，比较当前d[i]和每一个d[j] + 1的大小，将最大值赋给d[i]<br><em>(如果看不懂的话 让我们举一个例子吧~)</em></p><p><strong>e.g.</strong><br>5，3，4，8，6，7<br>&ensp;&ensp;+ 第一个数字5，d[0] = 1<br>&ensp;&ensp;+ 第一个数字3，前面没有比他还小的了，d[1] = 1<br>&ensp;&ensp;+ 第三个数字4，最长的递增子序列就是3，4，d[2] = 2<br>&ensp;&ensp;+ 第四个数组8，d[3] = 3<br>&ensp;&ensp;+ 第五个数字6，d[4] = 3, 此时的3是由d[2]+1<br>&ensp;&ensp;+ 第六个数字7，d[5] = 4</p><h3 id="二、-O-nlogn-方法-二分-DP"><a href="#二、-O-nlogn-方法-二分-DP" class="headerlink" title="二、$O(nlogn)$方法(二分+DP)"></a>二、$O(nlogn)$方法(二分+DP)</h3><p>在上面的例子中：<strong>3 4 8</strong> 6相比于与 <strong>3 4</strong> 8 <strong>6</strong> 显然后者更优<br>此时的状态为：<br>d[x] = d[y], 但是 A[x] &lt; A[y], 即选择x这个情况会比y这个情况好，在这种情况下保留x一定不会丢失最优解。所以对于相同的d[?]值，只需要保留A[i]较小的情况。</p><p><strong>e.g.</strong> (A、d从1开始)<br>序列A = {2, <strong>1</strong>, 5, <strong>3</strong>, 6, <strong>4</strong>, <strong>8</strong>, <strong>9</strong>, 7}<br>此时最长递增子序列(Longest Increasing Subsequence LIS) = 5</p><p><em>setp1:</em> 把A[1]有序地放到d里，令d[1] = 2，就是说当只有1一个数字2的时候，长度为1的LIS的最小末尾是2。这时Len=1</p><p><em>setp2:</em> 然后，把A[2]有序地放到d里，令d[1] = 1，就是说长度为1的LIS的最小末尾是1，A[1]=2已经没用了。这时Len=1</p><p><em>setp3:</em> 接着，A[3] = 5，d[3] &gt; d[1]，所以令d[3]=d[2]=d[3]=5，就是说长度为2的LIS的最小末尾是5，很容易理解吧。这时候B[1..2] = 1, 5，Len＝2</p><p><em>setp4:</em> 再来，d[4] = 3，它正好加在1,5之间，放在1的位置显然不合适，因为1小于3，长度为1的LIS最小末尾应该是1，这样很容易推知，长度为2的LIS最小末尾是3，于是可以把5淘汰掉，这时候B[1..2] = 1, 3，Len = 2</p><p><em>setp5:</em> 继续，d[5] = 6，它在3后面，因为B[2] = 3, 而6在3后面，于是很容易可以推知B[3] = 6, 这时B[1..3] = 1, 3, 6，还是很容易理解吧？ Len = 3 了噢。</p><p><em>setp6:</em> 第6个, d[6] = 4，你看它在3和6之间，于是我们就可以把6替换掉，得到B[3] = 4。B[1..3] = 1, 3, 4， Len继续等于3</p><p><em>setp7:</em>  第7个, d[7] = 8，它很大，比4大，嗯。于是B[4] = 8。Len变成4了</p><p><em>setp8:</em>  第8个, d[8] = 9，得到B[5] = 9，嗯。Len继续增大，到5了。</p><p><em>setp9:</em>  最后一个, d[9] = 7，它在B[3] = 4和B[4] = 8之间，所以我们知道，最新的B[4] =7，B[1..5] = 1, 3, 4, 7, 9，Len = 5。</p><p>于是我们知道了LIS的长度为5。</p><blockquote><p>hhh大概很有可能觉得疑惑的地方就是 这里的 为什么这里的7能替换8？<br>这也是为什么说 只能通过这样的方法算出 单调递增子序列的长度 而不能求出该子序列本身 why?<br>Reasons are as follows:</p></blockquote><p>此时取序列A = {2, <strong>1</strong>, 5, <strong>3</strong>, 6, <strong>4</strong>, <strong>8</strong>, <strong>9</strong>, 7}<br>按照上述方式序列应该变为A = {1, 3, 4, 7, 9}但是这样显然不符合序列A的单调递增模式。</p><p>若此时取序列A = {2, <strong>1</strong>, 5, <strong>3</strong>, 6, <strong>4</strong>, <strong>8</strong>, <strong>9</strong>, 7, <strong>10</strong>, <strong>11</strong>}<br>answer:{1, 3, 4, 7, 9, 10, 11}<br>real answer:{1, 3, 4, 8, 9, 10, 11}</p><p>若此时取序列A = {2, <strong>1</strong>, 5, <strong>3</strong>, 6, <strong>4</strong>, <strong>8</strong>, <strong>9</strong>, 7, 9, 10}<br>answer:{1, 3, 4, 7, 9, 10}<br>real answer:{1, 3, 4, 7, 9, 10}</p><p><strong>especially:<br>如果添加一个新数(即增加LIS的长度)，需要替换掉前面全部的数据，此时的序列为正确的序列</strong></p><p><strong><em>e.g.1.</em></strong> 若此时取序列A = {2, <strong>1</strong>, 5, <strong>3</strong>, 6, <strong>4</strong>, <strong>8</strong>, <strong>9</strong>, 7, 8, 9}<br>answer:{1, 3, 4, 7, 8, 9}<br>real answer:{1, 3, 4, 7, 8, 9}</p><p><strong><em>e.g.2.</em></strong> A={2, 4, <strong>1</strong>, <strong>3</strong>, <strong>4</strong>, 0}<br><strong><em>start:</em></strong> {2, 4}<br><em>setp1:</em> {1, 4}    1替换2, 序列不正确 但是长度为2正确<br><em>setp2:</em> {1, 3}    3替换4，序列正确，长度为2正确<br><em>setp3:</em> {1, 3, 4} 4直接接在序列后，序列正确，长度为3正确      <strong>!!!此时增加了LIS长度 数据也都被替换完毕了 所以此时为正确的最长递增序列形式</strong><br><em>setp4:</em> {0, 3, 4} 0替换1，序列不正确，长度为3正确。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先贴上别人的代码再说</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(a,n) memset(a,n,sizeof(a))</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">1e3</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N],a[N];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(~<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n))</span><br><span class="line">    &#123;</span><br><span class="line">        mem(dp,INF);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *lower_bound(dp,dp+n,a[i])=a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,lower_bound(dp,dp+n,INF)-dp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>感谢我徒弟的讲解与指导<br>想表达的就是这么多 虽然还是有点迷迷糊糊的 但是隐隐约约的懂了 </p></blockquote><p>NYOJ:单调递增子序列<br><a href="http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=17" target="_blank" rel="noopener">http://acm.nyist.edu.cn/JudgeOnline/problem.php?pid=17</a><br>Hihocoder:车队(需利用$O(nlogn)$才不会超时)<br><a href="http://hihocoder.com/problemset/problem/1684" target="_blank" rel="noopener">http://hihocoder.com/problemset/problem/1684</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最长递增子序列&quot;&gt;&lt;a href=&quot;#最长递增子序列&quot; class=&quot;headerlink&quot; title=&quot;最长递增子序列&quot;&gt;&lt;/a&gt;最长递增子序列&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;为啥不能使用暴力解决这个问题：设A串长为n. A串子序列个数$ 2^n $,判断其是否递增,时间复杂度变为:$ O(n*2^n) $. &lt;/p&gt;
&lt;font face=&quot;Console&quot;&gt;And of course we cannot accept that.&lt;br&gt;&lt;br&gt;所以出现了基本上以下三种方式：两个$O(n^2)$可求出序列本身，一个$ O(nlogn) $求出序列最大长度&lt;/font&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;前言：最长公共子序列&quot;&gt;&lt;a href=&quot;#前言：最长公共子序列&quot; class=&quot;headerlink&quot; title=&quot;前言：最长公共子序列&quot;&gt;&lt;/a&gt;前言：最长公共子序列&lt;/h3&gt;&lt;p&gt;子序列可以不连续，但是有先后的次序关系.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为啥不能使用暴力解决这个问题：设A串长为n, B串长为m。A串子序列个数$2^n$, B串子序列个数$2^m$, 针对每一种情况进行匹配，时间复杂度变为： $O(2^n*2^m)$. &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://yoursugars.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>xlrd与xlwt</title>
    <link href="https://yoursugars.github.io/2018/06/17/xlrd/"/>
    <id>https://yoursugars.github.io/2018/06/17/xlrd/</id>
    <published>2018-06-17T03:38:22.000Z</published>
    <updated>2018-06-17T07:04:37.057Z</updated>
    
    <content type="html"><![CDATA[<p>关于python中的xlrd和xlwt两个关于excel读写的库<br>hummm~主要是想到以后数模可能用python处理数据!</p><p><em>库名:</em><br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br></pre></td></tr></table></figure></p><p><em>下载地址:</em><br> [read]: <a href="https://pypi.org/project/xlrd/" target="_blank" rel="noopener">https://pypi.org/project/xlrd/</a> (xlrd)<br> [write]: <a href="https://pypi.org/project/xlwt/" target="_blank" rel="noopener">https://pypi.org/project/xlwt/</a> (xlwt)</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xlrd</span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line">data = xlrd.open_workbook(<span class="string">r'D:\software\python\sugar.xlsx'</span>)</span><br><span class="line">table = data.sheets()[<span class="number">0</span>]</span><br><span class="line">nrows = table.nrows<span class="comment">#行数</span></span><br><span class="line">ncols = table.ncols<span class="comment">#列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,nrows): </span><br><span class="line">rowValues = table.row_values(i)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> rowValues:</span><br><span class="line"><span class="keyword">print</span> (item, end = <span class="string">" "</span>)<span class="comment">#读</span></span><br><span class="line"><span class="keyword">print</span> ()</span><br><span class="line"></span><br><span class="line">file = xlwt.Workbook()</span><br><span class="line">sheet1 = file.add_sheet(<span class="string">'sheet1'</span>, cell_overwrite_ok = <span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, nrows):</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, ncols):</span><br><span class="line">sheet1.write(i,j,table.cell(i,j).value)<span class="comment">#写入</span></span><br><span class="line">file.save(<span class="string">'demo2.xlsx'</span>) <span class="comment">#save时有重复的不能覆盖</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#官方</span></span><br><span class="line"><span class="keyword">import</span> xlwt</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">style0 = xlwt.easyxf(<span class="string">'font: name Times New Roman, color-index red, bold on'</span>,</span><br><span class="line">num_format_str=<span class="string">'#,##0.00'</span>)</span><br><span class="line">style1 = xlwt.easyxf(num_format_str=<span class="string">'D-MMM-YY'</span>)</span><br><span class="line"></span><br><span class="line">wb = xlwt.Workbook()</span><br><span class="line">ws = wb.add_sheet(<span class="string">'A Test Sheet'</span>)</span><br><span class="line"></span><br><span class="line">ws.write(<span class="number">0</span>, <span class="number">0</span>, <span class="number">1234.56</span>, style0)</span><br><span class="line">ws.write(<span class="number">1</span>, <span class="number">0</span>, datetime.now(), style1)</span><br><span class="line">ws.write(<span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">ws.write(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ws.write(<span class="number">2</span>, <span class="number">2</span>, xlwt.Formula(<span class="string">"A3+B3"</span>))</span><br><span class="line"></span><br><span class="line">wb.save(<span class="string">'example.xls'</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure> ]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于python中的xlrd和xlwt两个关于excel读写的库&lt;br&gt;hummm~主要是想到以后数模可能用python处理数据!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;库名:&lt;/em&gt;&lt;br&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; xlrd&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; xlwt&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;下载地址:&lt;/em&gt;&lt;br&gt; [read]: &lt;a href=&quot;https://pypi.org/project/xlrd/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.org/project/xlrd/&lt;/a&gt; (xlrd)&lt;br&gt; [write]: &lt;a href=&quot;https://pypi.org/project/xlwt/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://pypi.org/project/xlwt/&lt;/a&gt; (xlwt)&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://yoursugars.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Selenium的简单学习</title>
    <link href="https://yoursugars.github.io/2018/06/16/PythonSelenium/"/>
    <id>https://yoursugars.github.io/2018/06/16/PythonSelenium/</id>
    <published>2018-06-16T13:40:53.000Z</published>
    <updated>2018-06-17T07:09:11.906Z</updated>
    
    <content type="html"><![CDATA[<p>Selenium主要用于自动化测试吧我想<br>只是在做工作室自动签到的时候了解到了<br>比起我徒弟之前把账号密码的形式通过cookie的形式发过去简单多了</p><p>自动签到不想再写第二遍，就看连接吧<br>[启明星工作室Python自动签到]: <a href="https://blog.csdn.net/qq_37430374/article/details/80665458" target="_blank" rel="noopener">https://blog.csdn.net/qq_37430374/article/details/80665458</a><br>反正我以后也不会常用csdn了~</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys <span class="comment">#快捷键</span></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.maximize_window()</span><br><span class="line">driver.implicitly_wait(<span class="number">6</span>)</span><br><span class="line">driver.get(<span class="string">"http://baidu.com/"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#八种定位方式</span></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>) </span><br><span class="line">driver.find_element_by_tag_name(<span class="string">"form"</span>) </span><br><span class="line">driver.find_element_by_link_text(<span class="string">"新闻"</span>)</span><br><span class="line">driver.find_element_by_partial_link_text(<span class="string">"主页"</span>).click()</span><br><span class="line">driver.find_element_by_class_name(<span class="string">"s_ipt"</span>)</span><br><span class="line">driver.find_element_by_css_selector(<span class="string">"#su"</span>)</span><br><span class="line"><span class="comment">#利用css或者xPath定位</span></span><br><span class="line"></span><br><span class="line">driver.find_element_by_id(<span class="string">"kw"</span>).clear()</span><br><span class="line">driver.refresh() <span class="comment"># 刷新方法 refresh  </span></span><br><span class="line">driver.back() <span class="comment">#后退</span></span><br><span class="line">driver.forward() <span class="comment">#前进</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印浏览器version的值</span></span><br><span class="line">print(driver.capabilities[<span class="string">'version'</span>])  </span><br><span class="line"><span class="comment"># current_url 方法可以得到当前页面的URL</span></span><br><span class="line"><span class="keyword">print</span> (driver.current_url)</span><br><span class="line"><span class="comment"># title方法可以获取当前页面的标题显示的字段</span></span><br><span class="line"><span class="keyword">print</span> (driver.title)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#在浏览器新建一个窗口 快捷键为control+t </span></span><br><span class="line"><span class="comment"># 触发ctrl+t 亲测在chrome有效</span></span><br><span class="line">ele = driver.find_element_by_tag_name(<span class="string">'body'</span>).send_keys(Keys.CONTROL + <span class="string">'t'</span>)</span><br><span class="line"><span class="comment">#利用js Firefox worked  </span></span><br><span class="line">driver.execute_script(<span class="string">"window.open('https://www.baidu.com')"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> driver.find_elements_by_xpath(<span class="string">"//*/input[@type='radio']"</span>):</span><br><span class="line">i.click()<span class="comment">#单选框</span></span><br><span class="line"><span class="comment">#判断是否被选中</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='news']"</span>).is_selected()  </span><br><span class="line"></span><br><span class="line">driver.set_window_size(<span class="number">1280</span>,<span class="number">800</span>)  <span class="comment"># 分辨率 1280*800</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#断言</span></span><br><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    <span class="keyword">assert</span> <span class="string">u"百度一下"</span> <span class="keyword">in</span> driver.title  </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Assertion test pass.'</span>)  </span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:  </span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Assertion test fail.'</span>, format(e)) </span><br><span class="line"><span class="comment">#获得页面元素大小</span></span><br><span class="line">search_btn = driver.find_element_by_id(<span class="string">'su'</span>)  </span><br><span class="line"><span class="keyword">print</span> (search_btn.size)  </span><br><span class="line"></span><br><span class="line"><span class="comment">#ActionChains模块支持，右键，鼠标悬停，拖拽，双击等动作</span></span><br><span class="line">actionChains = ActionChains(driver)  </span><br><span class="line">actionChains.context_click(element).send_keys(Keys.ARROW_DOWN).send_keys(Keys.ENTER).perform()  </span><br><span class="line"></span><br><span class="line"><span class="comment">#利用js 弹窗</span></span><br><span class="line">driver.execute_script(<span class="string">"window.alert('这是一个alert弹框。');"</span>) </span><br><span class="line"><span class="comment">#控制浏览器竖向滚动条</span></span><br><span class="line">target_elem = driver.find_element_by_link_text(<span class="string">"地区"</span>)  </span><br><span class="line">driver.execute_script(<span class="string">"return arguments[0].scrollIntoView();"</span>,target_elem) <span class="comment"># 用目标元素参考去拖动  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#点击之后 driver也变到这来·</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//*[@id='pane-news']/div/ul/li[1]/strong/a"</span>).click()  </span><br><span class="line"><span class="keyword">print</span> (driver.current_window_handle) <span class="comment"># 输出当前窗口句柄  </span></span><br><span class="line">handles = driver.window_handles <span class="comment"># 获取当前全部窗口句柄集合  </span></span><br><span class="line"><span class="keyword">print</span> (handles) <span class="comment"># 输出句柄集合  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> handle <span class="keyword">in</span> handles:<span class="comment"># 切换窗口  </span></span><br><span class="line">    <span class="keyword">if</span> handle != driver.current_window_handle:  </span><br><span class="line">        <span class="keyword">print</span> (<span class="string">'switch to second window'</span>,handle)   </span><br><span class="line">        driver.close() <span class="comment"># 关闭第一个窗口  </span></span><br><span class="line">        driver.switch_to.window(handle) <span class="comment">#切换到第二个窗口    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#若有iFrame</span></span><br><span class="line">driver.switch_to.frame(<span class="string">"iframe1"</span>)  </span><br><span class="line"><span class="comment"># 操作目标元素，这个目标元素在 iframe1里面，这里就是百度文本输入框输入文字  </span></span><br><span class="line">driver.switch_to.default_content() </span><br><span class="line"></span><br><span class="line">driver.execute_script(<span class="string">"window.alert('这是一个测试Alert弹窗');"</span>)  </span><br><span class="line">time.sleep(<span class="number">2</span>)  </span><br><span class="line">driver.switch_to_alert().accept()  <span class="comment"># 点击弹出里面的确定按钮  </span></span><br><span class="line">driver.switch_to_alert().dismiss() <span class="comment"># 点击弹出上面的X按钮  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> driver.find_elements_by_xpath(<span class="string">"//*[@href]"</span>):  </span><br><span class="line">    <span class="keyword">print</span> (link.get_attribute(<span class="string">'href'</span>))  </span><br><span class="line"></span><br><span class="line"><span class="comment">#保存图片</span></span><br><span class="line">driver.get_screenshot_as_file(<span class="string">"D:\\baidu.png"</span>)  </span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">driver.quit()  </span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Selenium主要用于自动化测试吧我想&lt;br&gt;只是在做工作室自动签到的时候了解到了&lt;br&gt;比起我徒弟之前把账号密码的形式通过cookie的形式发过去简单多了&lt;/p&gt;
&lt;p&gt;自动签到不想再写第二遍，就看连接吧&lt;br&gt;[启明星工作室Python自动签到]: &lt;a href=&quot;https://blog.csdn.net/qq_37430374/article/details/80665458&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_37430374/article/details/80665458&lt;/a&gt;&lt;br&gt;反正我以后也不会常用csdn了~&lt;/p&gt;
    
    </summary>
    
    
      <category term="Python" scheme="https://yoursugars.github.io/tags/Python/"/>
    
      <category term="Selenium" scheme="https://yoursugars.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>你不懂写文档的艺术</title>
    <link href="https://yoursugars.github.io/2018/06/15/%E4%BD%A0%E4%B8%8D%E6%87%82%E5%86%99%E6%96%87%E6%A1%A3%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <id>https://yoursugars.github.io/2018/06/15/你不懂写文档的艺术/</id>
    <published>2018-06-15T13:29:41.000Z</published>
    <updated>2018-06-19T03:41:21.264Z</updated>
    
    <content type="html"><![CDATA[<p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=512358238&auto=1&height=66"></iframe></p><h1 id="如何给word文档一个优美的排版？"><a href="#如何给word文档一个优美的排版？" class="headerlink" title="如何给word文档一个优美的排版？"></a>如何给word文档一个优美的排版？</h1><p>其实写这个的灵感来自于朱生豪先生写给她夫人宋清如的情书<br>大家可以看一看 当个文章引入吧。<br><a id="more"></a></p><blockquote><p>好人：<br><br></p><p>你不懂写信的艺术，像“请你莫怪我，我不肯嫁你”这种句子，怎么可以放在信的开头地方呢？你试想一想，要是我这信偶尔被别人在旁边偷看见了，开头第一句便是这样的话，我要不要难为情？理该是放在中段才是。否则把下面“今天天气真好，春花又将悄悄地红起来”二句搬在头上做帽子，也很好。“今天天气真好，春花又将悄悄地红起来，我没有什么意见”这样的句法，一点意味都没有；但如果说，“今天天气真好，春花又将悄悄地红起来，请你莫怪我，我不肯嫁你”，那就是绝妙好辞了。如果你缺少这种<font face="Console"> poetical instinct</font>，至少也得把称呼上的“朱先生”三字改做“好友”，或者肉麻一点就用“孩子”；你瞧“朱先生，请你莫怪我，我不肯嫁你”这样的话多么刺耳；“好友，请你莫怪我，我不肯嫁你”，就给人一个好像含有不得不苦衷的印象了，虽然本身的意义无二致；问题并不在“朱先生”或“好友”的称呼上，而是“请你莫怪我……”十个字，根本可以表示无情的拒绝和委婉的推辞两种意味。你该多读读《左传》。<br><br></p><p>我待你好，你也不要不待我好。</p></blockquote><hr><p>从数学建模写文档，有了严格的文档排版规定以来，我这个有着文档艺术的怪癖就没有变过来，次次看到大家姿态各一的文档排版，我就心里不开心，就想冲上去给人家改排版。</p><p>这不，昨天收到课设队友的文档，我半开玩笑式的写了一篇吐槽的文章。</p><blockquote><p>继上次看了朱生豪先生的责怪“你不懂写信的艺术”<br>想起来总觉得很好笑<br>我是不是该也写一个 “你不懂写文档的艺术”？<br><br></p><p>我也要怪你没有这种<font face="Console">literal instinct</font>，写文档可没有你想的那么没有艺术感。我知道懂得艺术感的朋友都该用<font face="Console">LaTex</font>去了，但就算是身处普通于面向群众的的<font face="Console">Word</font>，也该有一些你需知<font face="Console">routine</font>吧。<br><br></p><p>首先映入眼帘的就该是那大大小小的标题，标题前提示的一个黑点，该代表着什么呢？<br><br></p><p>“您可看好了，我这个标题可重要了”？您又是给标题加粗又是给它字体放大，还不把这个黑点给去掉，它能得有多重要，重要的都有些过分了。很多人不知道<font face="Console">Word</font>有标题层次，不知道它居然还有个导航窗口，这就是缺少了<font face="Console">routine</font>。你使用它的存在只是一种层次，从小到大的标题该有个大小区分吧，你说那大小都是一样的，文档右上方何必区分“标题1”，“标题2”，“标题3”呢？<br><br></p><p>一大段文字前的两个字，也不知道你想表达些什么，说是小标题也不大像，一点儿提示也不给。给个括号加个1，给个加粗或者斜体，不就在告诉人家，嘿，您看好了，我这下面要说的就是这这这。<br><br></p><p>整篇文档下来，大大小小的空行，就不说你的<font face="Console">word</font>或是<font face="Console">wps</font>没有打开换行提示符吧，你看不见换行符的时候觉得是“留白”，给看的见换行的朋友一看，留下这么多空行，总觉得你少写了点什么。<br><br></p><p>还有您可别在文档里说什么我们我们，文档里可不分你我。<br><br></p><p>中文的英文字符看着不是怪别扭的吗，本来应该有着流畅美的英文字符，该有种水到渠成的感觉，却硬生生地活像好似出国旅游的独在异乡为异客。所以该给他们找个家阿，给中文和英文各归属一个字体，不是一种舒畅吗。<br><br></p><p>所有的图片和表格不该给他们起个名字吗，在一群文字中孤零零的，怪可怜的。<br>更甚的是居然也不给它们使一个居中，就像是一个庞然大物被孤苦伶仃的当成几个文字，融不进去啊，活有一种离经叛道的感觉。<br><br></p><p>你说一群图片放在一起就不孤单了吧？是不孤单了， 你也得看看那不同图片里的文字大小是不是一样的啊。有的图片大到占了一整页A4的篇幅，有的小到里面的字都看不清，有的里面的字拉长地宽，有的字又紧缩地扁，形态各不相同，可真谓大杂烩。<br><br></p><p>可这图片也不是随随便便就给的几张图片阿，图片切忌模糊不清，又切忌大到占满整个篇幅。也更不能有多余的东西，一张图片里的内容本来就多的不行，您还给截一大堆多余的东西，不能随性阿。<br><br></p><p>更可气的就是到处留白了，两张细高的照片往那一戳，竖直的搁着跟想多占几张篇幅似的，放个表格给他俩并肩放着不该多好，不然看的人往下拉进度条拉了可久都不知道你这些图片是干嘛的。<br><br></p><p>最后的参考文献也够寒掺的，不知道您搁哪找的，每篇文献或是书籍，都有它标准的引用形式可以导出，您这放的别人正儿八经有归属的人，跟像无家可归的孩子一样。</p></blockquote><p>上面只是一些不正经的吐槽，既然吐槽完了那就开始正式地说什么是“word的艺术”吧。<br><br></p><hr><h1 id="word的艺术"><a href="#word的艺术" class="headerlink" title="word的艺术"></a>word的艺术</h1><h2 id="一、关于字体的设置"><a href="#一、关于字体的设置" class="headerlink" title="一、关于字体的设置"></a>一、关于字体的设置</h2><table><thead><tr><th style="text-align:center">标题级数</th><th style="text-align:center">字号</th><th style="text-align:center">字体</th><th style="text-align:center">对齐方式</th></tr></thead><tbody><tr><td style="text-align:center">一级标题</td><td style="text-align:center">三号</td><td style="text-align:center">黑体</td><td style="text-align:center">居中</td></tr><tr><td style="text-align:center">二级标题</td><td style="text-align:center">小三</td><td style="text-align:center">黑体</td><td style="text-align:center">左对齐</td></tr><tr><td style="text-align:center">三级标题</td><td style="text-align:center">小四</td><td style="text-align:center">宋体</td><td style="text-align:center">右对齐</td></tr><tr><td style="text-align:center">正文</td><td style="text-align:center">小四</td><td style="text-align:center">宋体</td><td style="text-align:center">首行缩进2个字符</td></tr></tbody></table><ul><li style="list-style: none"><input type="checkbox" checked> 在文章中若重要的关键词可<strong>加粗</strong>或者<em>斜体</em>显示</li><li style="list-style: none"><input type="checkbox" checked> 论文里从来不分你我，所以也没有<strong>“我们”</strong></li><li style="list-style: none"><input type="checkbox" checked> 做从不轻易空行(回车)的论文，不要留白，不要留有遐想的空间</li></ul><h2 id="二、关于图片与表格"><a href="#二、关于图片与表格" class="headerlink" title="二、关于图片与表格"></a>二、关于图片与表格</h2><p>1.无论是图片、表格还是表格里面的内容，都要保持居中的优美。<br><strong>ps:</strong>如果居中之后图片感觉并没有居中，那么原因是由于正文设置了首行缩进，这时取消该图片或者表格的首行缩进就可以了。</p><p>2.当然对于表格，自然有一种更加优美的格式<br><strong>全选-右键-自动调整-(根据内容自动调整/根据窗口自动调整)<br>或者：表格工具-布局-自动调整</strong></p><p>3.每个表格和图片都要有一个名字</p><table><thead><tr><th style="text-align:center">表</th><th style="text-align:center">图</th></tr></thead><tbody><tr><td style="text-align:center">表一、表二</td><td style="text-align:center">图1、图2</td></tr></tbody></table><p>至于名字放在哪？有一个口诀：表头与图尾各占0.5行。<br><strong>设置方式：段落-间距-段前/段后。</strong></p><p>表内外字体大小统一、表格有很多样式，要做的漂亮但是不能花哨，让人看上去很顺眼。图表最好都一般大小，保证一页之内的图标一样大。最后如果图片的结构类似，可以利用表格固定并排的两张图片。looks like this:</p><table><thead><tr><th style="text-align:center">图片a</th><th style="text-align:center">图片b</th></tr></thead><tbody><tr><td style="text-align:center">图片a的名字</td><td style="text-align:center">图片b的名字</td></tr></tbody></table><p>然后再把表格线取消就好了，看起来就是两张图片并排放置。总觉得这样太巧妙。</p><h2 id="三、mathtype"><a href="#三、mathtype" class="headerlink" title="三、mathtype"></a>三、mathtype</h2><p>1.不要放大<br>2.公式居中，美赛的时候会在公式结尾靠右给一个(1)<br>数字标识表示应该靠右，会有一种独特的美感。<br>3.关于公式网上浮：重新粘贴，或者<strong>选中-段落-取消文档网格</strong></p><h2 id="四、流程图"><a href="#四、流程图" class="headerlink" title="四、流程图"></a>四、流程图</h2><p>1.visio欢迎你<br>2.如果你非要用word画流程图，请利用<strong>插入-形状-新建绘图画布</strong><br>其实你总有一天会投奔很多软件，visio就是其中之一</p><h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><p>我想了很多，如果让我重新参加一次培训，我会学些什么。17年的暑假整个人呈现出一种萧条的感觉，基本上就麻木的写作。我少些灵气，不知道做什么样的图表好看，该怎么展示这个结果。怎么补足这个缺点呢？多学点手艺傍身，途径变多了，就知道怎么展示了。</p><p><strong>SPSS/Python/LaTex</strong></p><p><em>SPSS</em> : 身为一个写作，我很遗憾的地方就是我不擅长做数据分析。因此使论文少了很大的一个亮点。</p><p><em>Python</em> : 选题避免不了会选择开放题B题，就避免不了的要找数据，身为学计算机的一员，不能利用python爬数据这件事一直是我的一个遗憾。这里讲一个小插曲，在我们18年参加美赛的时候，我让我一个学长帮忙爬数据，后来我们换题之后把数据给卖了，还挣了一波钱hhh很奇妙吧，我们现在三个人都在学python,以后专业卖数据。</p><p><em>LaTex</em> : 想学LaTex的心情也很单纯，主要是用累了word的排版方式，总觉得很繁琐很累。看了大多学术性的论文都是用LaTex排版，又漂亮，又是通过编程实现的，感觉很优美，心生羡慕是一定的。</p><h2 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h2><h3 id="1-1-摘要的注意事项"><a href="#1-1-摘要的注意事项" class="headerlink" title="1.1.摘要的注意事项"></a>1.1.摘要的注意事项</h3><p>(1).占整页的3/4比较好<br>(2).摘要里的表格不能有表头，且表以黑白为主，不能有图片<br>(3).避免数学公式字符与<strong>我们</strong> (一句话有“我们”，太过主观)<br>(4).摘要里不能有参考文献标识<br>(5).题目问了的一定要表现出来，题目没有问的选择性表达<br>(6).摘要就挤挤吧，看起来比较紧凑</p><h3 id="1-2-摘要内容"><a href="#1-2-摘要内容" class="headerlink" title="1.2.摘要内容"></a>1.2.摘要内容</h3><p>(1).为什么(一句话概括原因)<br>(2).怎么做(针对问题一、问题二，采用…的方法，建立什么模型)<br>(3).有结果(尽量选取重要的部分简单利用表格表达)</p><h3 id="1-3-关键字"><a href="#1-3-关键字" class="headerlink" title="1.3.关键字"></a>1.3.关键字</h3><pre><code>关键字不必打到最后一行，利用分页符，并且关键字一定要在摘要中选取。关键字的内容：(1).反映问题(2).方法(3).模型是什么类型很傻的一种就是告诉别人我用了matlab、excel得出什么结果，因为大家都用的是这个。</code></pre><h2 id="二、问题重述"><a href="#二、问题重述" class="headerlink" title="二、问题重述"></a>二、问题重述</h2><h3 id="2-1-问题背景"><a href="#2-1-问题背景" class="headerlink" title="2.1.问题背景"></a>2.1.问题背景</h3><p>迎着问题的背景回答。</p><h3 id="2-2-需要解决的问题"><a href="#2-2-需要解决的问题" class="headerlink" title="2.2.需要解决的问题"></a>2.2.需要解决的问题</h3><p>(1).问题相关<br>(2).需要解决的问题<br>基本上由于查重这件事情的存在，所有的东西都要用自己的话再描述一遍。貌似？12个连续的字查重？</p><h2 id="三、问题假设与符号说明"><a href="#三、问题假设与符号说明" class="headerlink" title="三、问题假设与符号说明"></a>三、问题假设与符号说明</h2><h3 id="3-1-问题假设"><a href="#3-1-问题假设" class="headerlink" title="3.1.问题假设"></a>3.1.问题假设</h3><p>这个真的很搞笑，假设的一定要有意义才行。像什么”题目给的数据准确无误”、”收集的数据正确”这样怀疑题目的正确性或者说了跟没说一样的假设还不如不写。<br>4-5个即可</p><h3 id="3-2-符号说明"><a href="#3-2-符号说明" class="headerlink" title="3.2.符号说明"></a>3.2.符号说明</h3><p>这个随意阿，做个表格规规矩矩摆在那里就好。之前在美赛的时候，把符号说明拆散分配到每一个模型的下面，觉得这样也很漂亮，看自己。<br>① 不用表头，注意布局<br>② 尽量放在同一页里，上面的内容进行调整或者调整段前段后<br>③ 尽量使用最简单的变量，在24个字母不够用的情况下选择用希腊字母<br>可以尝试直接解决一个问题在解决第二个问题，这样问题分析，数据分析，模型的建立可以放在一起更加清晰明了</p><h2 id="四、问题分析"><a href="#四、问题分析" class="headerlink" title="四、问题分析"></a>四、问题分析</h2><p>1.不能出现模型的字符和公式<br>2.流程图<br>3.“我还不知道要怎么做，可以用某种方法去解决这个问题”这样的语气</p><h2 id="五、数据分析与处理"><a href="#五、数据分析与处理" class="headerlink" title="五、数据分析与处理"></a>五、数据分析与处理</h2><ol><li>分析之前说一下要干嘛</li><li>处理数据就是，除了题目给的数据，做一些变动，通过转化为需要的数据，并且可以与后文的结果 <strong>相呼应</strong><h2 id="六、问题一模型的建立与求解"><a href="#六、问题一模型的建立与求解" class="headerlink" title="六、问题一模型的建立与求解"></a>六、问题一模型的建立与求解</h2>hhh这个标题真的很巧妙了，知道为啥吗？为了避免模型有优化或者一个问题有多个模型的情况。如果是模型一的建立与求解，就完全写不了了。<h3 id="6-1-模型建立前的准备"><a href="#6-1-模型建立前的准备" class="headerlink" title="6.1.模型建立前的准备"></a>6.1.模型建立前的准备</h3><h3 id="6-2-模型的建立"><a href="#6-2-模型的建立" class="headerlink" title="6.2.模型的建立"></a>6.2.模型的建立</h3><h3 id="6-3-模型的求解"><a href="#6-3-模型的求解" class="headerlink" title="6.3.模型的求解"></a>6.3.模型的求解</h3><h3 id="6-4-结果分析"><a href="#6-4-结果分析" class="headerlink" title="6.4.结果分析"></a>6.4.结果分析</h3>适当标黑<br>步骤清晰明了<br>厉害的模型<br>拿奖的亮点和新意。<h3 id="6-5-误差分析-灵敏度分析"><a href="#6-5-误差分析-灵敏度分析" class="headerlink" title="6.5.误差分析/灵敏度分析"></a>6.5.误差分析/灵敏度分析</h3>这些拿出来单独做一个专栏也没问题，具体看题目。<h2 id="七、模型的评价，改进及推广"><a href="#七、模型的评价，改进及推广" class="headerlink" title="七、模型的评价，改进及推广"></a>七、模型的评价，改进及推广</h2><strong>评价之后才能改进。</strong><br>我从来没有写过这个部分，基本上都是最后赶工的时候我编程队友帮我写的。这个专栏就是那种，你不写就少了什么，你写了别人也不看，除非你说的跟花似的，有格外的亮点和心意就是加分项。<h2 id="八、参考文献"><a href="#八、参考文献" class="headerlink" title="八、参考文献"></a>八、参考文献</h2>为了保证参考文献的格式，直接从知网导出来就好了。<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2>附录附上代码、以及在正文无法表示的超过1/2的表格</li></ol><hr><p>最后我全文强调的心意：</p><ol><li>对比</li><li>各种图 流程图 对比图 过程图 </li><li>各种方法<br>模型优化<br>蒙特卡洛<br>误差分析<br>计算机模拟（随机数检验）<br>灵敏度分析<br>别人想不到的 你要想到 别人想到的 你要做的新颖 然后你拿的奖项就能前进一步</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot; height=&quot;86&quot; src=&quot;//music.163.com/outchain/player?type=2&amp;id=512358238&amp;auto=1&amp;height=66&quot;&gt;&lt;/iframe&gt;&lt;/p&gt;
&lt;h1 id=&quot;如何给word文档一个优美的排版？&quot;&gt;&lt;a href=&quot;#如何给word文档一个优美的排版？&quot; class=&quot;headerlink&quot; title=&quot;如何给word文档一个优美的排版？&quot;&gt;&lt;/a&gt;如何给word文档一个优美的排版？&lt;/h1&gt;&lt;p&gt;其实写这个的灵感来自于朱生豪先生写给她夫人宋清如的情书&lt;br&gt;大家可以看一看 当个文章引入吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="数学建模" scheme="https://yoursugars.github.io/tags/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1/"/>
    
  </entry>
  
</feed>
